<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>ブロック崩し</title>
  <style>
    :root { --ui:#111; --bg:#fafafa; }
    html,body{ height:100%; margin:0; background:var(--bg); font-family:system-ui, sans-serif; }
    .wrap{ display:grid; place-items:center; height:100%; padding:12px; box-sizing:border-box; }
    .hud{
      position:fixed; top:10px; left:10px; background:#fff; border:1px solid #ddd;
      border-radius:10px; padding:6px 10px; font-size:14px; box-shadow:0 4px 10px #0001;
    }
    canvas{ background:#fff; border:2px solid var(--ui); border-radius:14px; touch-action:none; }
    .overlay{
      position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
    }
    .badge{
      background:#fff; border:2px solid var(--ui); border-radius:16px; padding:12px 16px;
      font-weight:700; box-shadow:0 6px 18px #0002; pointer-events:auto; cursor:pointer;
      user-select:none;
    }
    .tip{ position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
      background:#fff; border:1px solid #ddd; padding:6px 10px; border-radius:10px; font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="480" height="720" aria-label="ブロック崩し"></canvas>
    <div class="overlay" id="overlay">
      <div class="badge" id="startBtn">▶ スタート</div>
    </div>
    <div class="hud">スコア: <span id="score">0</span>　ライフ: <span id="lives">3</span></div>
    <div class="tip">操作：マウス/指でパドル移動（左右）</div>
  </div>

  <script>
  (function(){
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    function fitHiDPI(){
      const rect = cvs.getBoundingClientRect();
      cvs.width  = Math.floor(rect.width  * dpr);
      cvs.height = Math.floor(rect.height * dpr);
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }
    // 画面サイズ（CSS）固定：内部はdprで高解像度
    cvs.style.width  = '480px';
    cvs.style.height = '720px';
    fitHiDPI();
    window.addEventListener('resize', fitHiDPI);

    const W = 480, H = 720;

    // ──★ パドル（幅150px版）★──
    const paddle = { w: 150, h: 14, x: (W-150)/2, y: H-60, speed: 12 };

    // ボール
    const ball = { x: W/2, y: H-80, r: 8, vx: 4, vy: -6, speedCap: 11 };

    // ブロック
    const rows = 6, cols = 8;
    const brick = { w: 50, h: 20, gap: 8, top: 80, left: 22 };
    brick.w = Math.floor((W - brick.left*2 - (cols-1)*brick.gap) / cols);

    let bricks = [];
    function resetBricks(){
      bricks = [];
      const palette = ['#222','#333','#444','#555','#666','#777'];
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          bricks.push({
            x: brick.left + c*(brick.w + brick.gap),
            y: brick.top  + r*(brick.h + brick.gap),
            w: brick.w, h: brick.h, alive: true, color: palette[r%palette.length]
          });
        }
      }
    }

    let score = 0, lives = 3, running = false, waiting = true;

    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    // 入力（マウス・タッチ）
    function setPaddleByClientX(clientX){
      const rect = cvs.getBoundingClientRect();
      const x = clientX - rect.left;
      paddle.x = clamp(x - paddle.w/2, 6, W - paddle.w - 6);
    }
    cvs.addEventListener('mousemove', (e)=>{ if(!waiting) setPaddleByClientX(e.clientX); });
    cvs.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(waiting) return; setPaddleByClientX(e.touches[0].clientX); }, {passive:false});
    cvs.addEventListener('touchmove',  (e)=>{ e.preventDefault(); if(waiting) return; setPaddleByClientX(e.touches[0].clientX); }, {passive:false});

    // ゲーム開始・新ボール
    function newBall(){
      ball.x = paddle.x + paddle.w/2;
      ball.y = paddle.y - 16;
      const speed = 7;
      const angle = (-Math.PI/3) + Math.random()* (Math.PI/3);
      ball.vx = speed * Math.cos(angle);
      ball.vy = speed * Math.sin(angle) - 6;
    }

    function startGame(){
      resetBricks();
      score = 0; lives = 3;
      scoreEl.textContent = score; livesEl.textContent = lives;
      paddle.x = (W - paddle.w)/2;
      newBall();
      waiting = false; running = true;
      overlay.style.display = 'none';
    }

    function lifeLost(){
      lives--;
      livesEl.textContent = lives;
      if(lives <= 0){
        running = false; waiting = true;
        startBtn.textContent = '🔁 もう一度';
        overlay.style.display = 'grid';
      }else{
        waiting = true;
        startBtn.textContent = '▶ 続ける';
        overlay.style.display = 'grid';
        newBall();
      }
    }

    function maybeWin(){
      if(bricks.every(b=>!b.alive)){
        running = false; waiting = true;
        startBtn.textContent = '🏆 クリア！もう一度';
        overlay.style.display = 'grid';
      }
    }

    // 衝突判定
    function hitRect(cx, cy, r, rx, ry, rw, rh){
      const nx = clamp(cx, rx, rx+rw);
      const ny = clamp(cy, ry, ry+rh);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx + dy*dy) <= r*r;
    }

    function reflectBallOnRect(rx,ry,rw,rh){
      const prevX = ball.x - ball.vx, prevY = ball.y - ball.vy;
      const fromLeft   = prevX <= rx && ball.x > rx;
      const fromRight  = prevX >= rx+rw && ball.x < rx+rw;
      const fromTop    = prevY <= ry && ball.y > ry;
      const fromBottom = prevY >= ry+rh && ball.y < ry+rh;

      if((fromLeft && !fromTop && !fromBottom) || (fromRight && !fromTop && !fromBottom)){
        ball.vx *= -1;
      }else if((fromTop && !fromLeft && !fromRight) || (fromBottom && !fromLeft && !fromRight)){
        ball.vy *= -1;
      }else{
        ball.vx *= -1; ball.vy *= -1;
      }
    }

    function draw(){
      ctx.clearRect(0,0,W,H);

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#111';
      ctx.strokeRect(6, 6, W-12, H-12);

      // パドル
      ctx.fillStyle = '#111';
      ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

      // ブロック
      for(const b of bricks){
        if(!b.alive) continue;
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.fillStyle = '#fff';
        ctx.fillRect(b.x+2, b.y+2, b.w-4, b.h-4);
      }

      // ボール
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fillStyle = '#111';
      ctx.fill();
    }

    function update(){
      if(!running || waiting) return;

      const speed = Math.hypot(ball.vx, ball.vy);
      if(speed > ball.speedCap){
        const s = ball.speedCap / speed;
        ball.vx *= s; ball.vy *= s;
      }

      ball.x += ball.vx;
      ball.y += ball.vy;

      // 壁反射
      if(ball.x - ball.r < 8){ ball.x = 8 + ball.r; ball.vx *= -1; }
      if(ball.x + ball.r > W-8){ ball.x = W-8 - ball.r; ball.vx *= -1; }
      if(ball.y - ball.r < 8){ ball.y = 8 + ball.r; ball.vy *= -1; }

      // 落下
      if(ball.y - ball.r > H){ lifeLost(); }

      // パドル衝突
      if(hitRect(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, paddle.h) && ball.vy > 0){
        const hitPos = (ball.x - paddle.x) / paddle.w; // 0..1
        const angle = (hitPos - 0.5) * Math.PI * 0.7;
        const sp = Math.min(ball.speedCap, Math.hypot(ball.vx, ball.vy) * 1.03);
        ball.vx = Math.cos(angle) * sp;
        ball.vy = -Math.abs(Math.sin(angle) * sp) - 4;
        ball.y = paddle.y - ball.r - 0.1;
      }

      // ブロック衝突
      for(const b of bricks){
        if(!b.alive) continue;
        if(hitRect(ball.x, ball.y, ball.r, b.x, b.y, b.w, b.h)){
          b.alive = false;
          score += 10; scoreEl.textContent = score;
          reflectBallOnRect(b.x, b.y, b.w, b.h);
          maybeWin();
          break;
        }
      }
    }

    function loop(){
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    startBtn.addEventListener('click', ()=>{
      if(lives <= 0 || bricks.every(b=>!b.alive)){
        score = 0; lives = 3; scoreEl.textContent = score; livesEl.textContent = lives;
        resetBricks();
      }
      waiting = false; running = true;
      overlay.style.display = 'none';
      if(ball.y > H-90) newBall();
    });

    // 初期化
    resetBricks();
  })();
  </script>
</body>
</html>
